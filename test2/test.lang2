fn test_eq(name: string, expected: int, actual: int) {
    print(name);
    print(" => ");

    if expected = actual {
        println("\x1b[92msucceed\x1b[0m");
    } else {
        print("\x1b[91m");
        print("expected:");
        printn(expected);
        print(", actual:");
        printnln(actual);
        print("\x1b[0m");
    }
}

fn test(name: string, ok: bool) {
    print(name);
    print(" => ");

    if ok {
        println("\x1b[92msucceed\x1b[0m");
    } else {
        println("\x1b[91mfailed\x1b[0m");
    }
}

## literals ##

test_eq("zero", 0, 0);
test_eq("one", 1, 1);
test_eq("binary number", 5, 0b101);
test_eq("octal number", 27, 033);
test_eq("hex number", 127, 0x7f);

## binary operators ##

test_eq("add", 9, 5 + 4);
test_eq("sub", 13, 20 - 7);
test_eq("mul", 2714195, 809 * 3355);
test_eq("div 1", 3, 9 / 3);
test_eq("div 2", 2, 8 / 3);
test_eq("priority", 18, 3 + 7 * 4 - 13);

let a = 3 + 35;
test("equal", 38 = 38);
test("not equal", 38 <> 39);
test("less than", 35 < 39);
test("less than or equal", 38 <= 38);
test("greater than", 33 > 30);
test("greater than or equal", 93 >= 31);
test("and", true && true);
test("or", false || true);

let a = 384123;
a = 83901 && add_3(&a) = 5312;
test_eq("short-circuit evalution in &&", 384123, a);

a = 384123 || add_3(&a) = 5312;
test_eq("short-circuit evalution in ||", 384123, a);

fn add_3(n: *int): int {
    *n := 3095;
    return 5312;
}

## variable ##

let a = 3 + 35;
test_eq("binding", 38, a);

let c = a;
test_eq("copy", 38, c);

let b = 10;
{
    let b = 13;
}
test_eq("scope", 10, b);

let b = 30;
test_eq("shadowing", 30, b);

b := 931;
test_eq("assign", 931, b);

## function ##

test_eq("simple function", 30, add(14, 16,));
test_eq("no parameter", 33019, no_param());
test_eq("early return", 1000, early_return(3));
test_eq("fibonacci", 55, fib(10));
no_return(51633);

fn add(a: int, b: int,): int {
    return a + b;
}

fn no_param(): int {
    return 33019;
}

fn no_return(a: int) {
}

fn early_return(a: int): int {
    if a < 5 {
        return 1000;
    }

    return 500000;
}

fn fib(n: int): int {
    if n = 0 || n = 1 {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

## tuple ##

test_eq("tuple indexing 1", 3, (3, 8, 4, 9).0);
test_eq("tuple indexing 2", 9, (3, 8, 4, 9).3);
test_eq("tuple indexing 3", 8, (3, 8, 4, 9).1);

let tuple = (4314, (901, 149),);
tuple.0 := 344;
tuple.1 := (63, 13490);
test_eq("assign by tuple indexing 1", 344, tuple.0);
test_eq("assign by tuple indexing 2", 13490, tuple.1.1);

test_eq("nested tuple indexing", 132, ((52, 93012, 341), (5, 132), 63).1.1);
let tuple = ((52, 93012, 341), (5, 132, 9), 63);
test_eq("variable tuple indexing", 9, tuple.1.2);

test("function passed a tuple", tuple((5, 3, 8)));
test_eq("function returning a tuple", 12, double((3, 6)).1);

fn tuple(t: (int, int, int)): bool {
    return t.0 = 5 && t.1 = 3 && t.2 = 8;
}

fn double(t: (int, int)): (int, int) {
    return (t.0 * 2, t.1 * 2);
}

## pointer ##

let value = 1395;
let ptr = &value;
test_eq("dereference", 1395, *ptr);
*ptr := 538081;
test_eq("assign to a value dereferenced", 538081, value);

let tuple = (1, 3, 5);
let ptr = &tuple.1;
*ptr := 923;
test_eq("pointer to a field", 923, tuple.1);

add_2(&tuple.2);
test_eq("function passed a pointer", 7, tuple.2);

fn add_2(n: *int): () {
    *n := *n + 2;
    return;
}

## other expressions ##

test_eq("negative", -39, -15 - 24);
