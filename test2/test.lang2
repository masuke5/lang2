import assert::{testo as test, test_eq};
import module::module1::*;

## literals ##

test_eq "zero" 0 0;
test_eq "one" 1 1;
test_eq "binary number" 5 0b101;
test_eq "octal number" 27 033;
test_eq "hex number" 127 0x7f;

## binary operators ##

test_eq "add 1" 9 (5 + 4);
test_eq "add 2" 444 (567 + -123);
test_eq "sub 1" 13 (20 - 7);
test_eq "sub 1" (-27) (-20 - 7);
test_eq "mul 1" 2714195 (809 * 3355);
test_eq "mul 2" (-219) (73 * -3);
test_eq "div 1" 3 (9 / 3);
test_eq "div 2" 2 (8 / 3);
test_eq "div 3" (-16) (50 / -3);
test_eq "priority" 18 (3 + 7 * 4 - 13);

let a = 3 + 35;
test "equal" (38 = 38);
test "not equal" (38 <> 39);
test "less than" (35 < 39);
test "less than or equal" (38 <= 38);
test "greater than" (33 > 30);
test "greater than or equal" (93 >= 31);
test "and" (true && true);
test "or" (false || true);

let b = 8149712421;
let ptr1 = &a;
let ptr2 = &a;
let ptr3 = &b;
test "pointer comparison 1" (ptr1 = ptr2);
test "pointer comparison 2" (ptr2 <> ptr3);

let mut a = 384123;
a = 83901 && add_3 (&mut a) = 5312;
test_eq "short-circuit evalution in &&" 384123 a;

a = 384123 || add_3 (&mut a) = 5312;
test_eq "short-circuit evalution in ||" 384123 a;

fn add_3(n: *mut int): int = {
    *n := 3095;
    5312
}

## variable ##

let a = 3 + 35;
test_eq "binding" 38 a;

let c = a;
test_eq "copy" 38 c;

let b = 10;
{
    let b = 13;
}
test_eq "scope" 10 b;

let mut b = 30;
test_eq "shadowing 1" 30 b;

let x = 31413;
let y = &x;
let x = 192;
test_eq "shadowing 2" 31413 (*y);

b := 931;
test_eq "assign" 931 b;

## function ##

test_eq "simple function" 30 (add 14 16);

let func = add;
test_eq "function as value" 40 (func 33 7);

test_eq "no parameter" 33019 (no_param ());
test_eq "early return" 1000 (early_return 3);
test_eq "fibonacci" 55 (fib 10);
no_return 51633;

let xxx = 3000;

fn add1(x: int): int = {
    let z = 30;
    fn add2(y: int): int = {
        fn add3(): int = x + y + z + xxx;
        add3 ()
    }
    add2 5
}

test_eq "escaped variable and parameter" 3038 (add1 3);

fn add(a: int, b: int,): int = {
    a + b
}

fn no_param(): int = {
    33019
}

fn no_return(mut a: int) = {
    a := 93017;
}

fn early_return(a: int): int = {
    if a < 5 {
        return 1000;
    }

    500000
}

fn fib(n: int): int = {
    if n = 0 || n = 1 {
        n
    } else {
        (fib (n - 1)) + (fib (n - 2))
    }
}

## tuple ##

test_eq "tuple indexing 1" 3 (3, 8, 4, 9).0;
test_eq "tuple indexing 2" 9 (3, 8, 4, 9).3;
test_eq "tuple indexing 3" 8 (3, 8, 4, 9).1;

let mut tuple = (4314, (901, 149),);
tuple.0 := 344;
tuple.1 := (63, 13490);
test_eq "assign by tuple indexing 1" 344 tuple.0;
test_eq "assign by tuple indexing 2" 13490 tuple.1.1;

test_eq "nested tuple indexing" 132 ((52, 93012, 341), (5, 132), 63).1.1;
let tuple = ((52, 93012, 341), (5, 132, 9), 63);
test_eq "variable tuple indexing" 9 tuple.1.2;

test "function passed a tuple" (check_tuple (5, 3, 8));
test_eq "function returning a tuple" 12 (double (3, 6)).1;

fn check_tuple(t: (int, int, int,)): bool = t.0 = 5 && t.1 = 3 && t.2 = 8;
fn double(t: (int, int)): (int, int) = (t.0 * 2, t.1 * 2); 

## pointer ##

let mut value = 1395;
let ptr = &mut value;
test_eq "dereference" 1395 (*ptr);
*ptr := 538081;
test_eq "assign to a value dereferenced" 538081 value;

let mut tuple = (1, 3, 5);
let ptr = &mut tuple.1;
*ptr := 923;
test_eq "pointer to a field" 923 tuple.1;

add_2 (&mut tuple.2);
test_eq "function passed a pointer" 7 tuple.2;

fn add_2(n: *mut int): () = {
    *n := *n + 2;
    return;
}

let tuple = (3141, 1314, 939);
let ptr = &tuple;
test_eq "dereference tuple field" 1314 ptr.1;

let person = Person:{ name: "aa", age: 34, child: Child:{ age: 1, age_in_months: 0 } };
let ptr = &person;
test_eq "dereference struct field" 34 ptr.age;

## structure ##

type Child struct {
    age: int,
    age_in_months: int,
};

type Person struct {
    name: *string,
    age: int,
    child: Child,
};

let name = "Tarou";
let person = Person:{
    age: 234,
    name: name,
    child: Child:{
        age: 0,
        age_in_months: 8, 
    },
};

test_eq "struct field 1" 234 person.age;
test_eq "struct field 2" 0 person.child.age;
test_eq "struct field 3" 8 person.child.age_in_months;

## heap ##

let person = new mut Person:{ name: "aaaaaaaaa", age: 1000000, child: Child:{ age: 999950, age_in_months: 11 } };
test_eq "struct in heap" 11 person.child.age_in_months;

person.age := person.age - 1;
test_eq "assign to struct in heap" 999999 person.age;

## array ##

let mut arr = [3; 10];
test_eq "array subscript" 3 arr[0];

arr[3] := 9134;
test_eq "assign to array" 9134 arr[3];

let ptr = &mut arr;
ptr[4] := 30984304;
test_eq "assign to pointer to array" 30984304 arr[4];

test_eq "function passed array" 30993462 (sum arr);
test_eq "function returning array" 4 (one_to_ten ())[3];

fn sum(arr: [int; 10]): int = {
    let mut i = 0;
    let mut result = 0;

    while i < 10 {
        result := result + arr[i];
        i := i + 1;
    }

    result
}

fn one_to_ten(): [int; 10] = {
    let mut arr = [0; 10];
    let mut i = 0;

    while i < 10 {
        arr[i] := i + 1;
        i := i + 1;
    }

    arr
}

## parametric polymorphism ##

type Value<T> struct {
    v: T,
    next: *Node<T>,
};

type Node<T> struct {
    value: Value<T>,
};

let node = Node:<int> {
    value: Value: {
        v: 12410943,
        next: __null__,
    },
};
test_eq "mutually recursive data type" 12410943 node.value.v;

fn f<T>(x: T): T = x;
fn f2<T>(x: T): T = f.<T> x; 
fn f3<T>(x: (int, T, T)): (T, T, T) = (x.1, x.2, x.1); 

type A<T> struct {
    b: T,
    c: int,
};

let value = f2 139857;
test_eq "call with instantiation 1" 139857 value;
let tuple = f2 (31847, 138947);
test_eq "call with instantiation 2" 170794 (tuple.0 + tuple.1);

let aaa = f3 (
    921303124,
    A:{ b: "abc", c: 123 },
    A:<*string>{ b: "def", c: 456 },
);
test_eq "call with instantiation 3" 702 (aaa.0.c + aaa.1.c + aaa.2.c);

## import ##
test_eq "mutually importing" 243 (pow 3 5); 

## other expressions ##

test_eq "negative" (-39) (-15 - 24);

let num = {
    let num = 120944;
    {
        num + 90324
    }
};
test_eq "block expression" 211268 num;

let num = if false {
    9318051
} else {
    f 12834
};
test_eq "if expression" 12834 num;
